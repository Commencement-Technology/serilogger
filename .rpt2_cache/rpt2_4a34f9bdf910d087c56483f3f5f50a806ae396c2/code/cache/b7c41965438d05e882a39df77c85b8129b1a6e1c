{"code":"var Pipeline = /** @class */ (function () {\r\n    function Pipeline() {\r\n        this.stages = [];\r\n        this.eventQueue = [];\r\n        this.flushInProgress = false;\r\n    }\r\n    /**\r\n     * Adds a stage to the end of the pipeline.\r\n     * @param {PipelineStage} stage The pipeline stage to add.\r\n     */\r\n    Pipeline.prototype.addStage = function (stage) {\r\n        this.stages.push(stage);\r\n    };\r\n    /**\r\n     * Emits events through the pipeline. If a flush is currently in progress, the events will be queued and will been\r\n     * sent through the pipeline once the flush is complete.\r\n     * @param {LogEvent[]} events The events to emit.\r\n     */\r\n    Pipeline.prototype.emit = function (events) {\r\n        var _this = this;\r\n        if (this.flushInProgress) {\r\n            this.eventQueue = this.eventQueue.concat(events);\r\n            return this.flushPromise;\r\n        }\r\n        else {\r\n            if (!this.stages.length || !events.length) {\r\n                return Promise.resolve();\r\n            }\r\n            var promise = Promise.resolve(this.stages[0].emit(events));\r\n            var _loop_1 = function (i) {\r\n                promise = promise.then(function (events) { return _this.stages[i].emit(events); });\r\n            };\r\n            for (var i = 1; i < this.stages.length; ++i) {\r\n                _loop_1(i);\r\n            }\r\n            return promise;\r\n        }\r\n    };\r\n    /**\r\n     * Flushes events through the pipeline.\r\n     * @returns A {Promise<any>} that resolves when all events have been flushed and the pipeline can accept new events.\r\n     */\r\n    Pipeline.prototype.flush = function () {\r\n        var _this = this;\r\n        if (this.flushInProgress) {\r\n            return this.flushPromise;\r\n        }\r\n        this.flushInProgress = true;\r\n        return (this.flushPromise = Promise.resolve()\r\n            .then(function () {\r\n            if (_this.stages.length === 0) {\r\n                return;\r\n            }\r\n            var promise = _this.stages[0].flush();\r\n            var _loop_2 = function (i) {\r\n                promise = promise.then(function () { return _this.stages[i].flush(); });\r\n            };\r\n            for (var i = 1; i < _this.stages.length; ++i) {\r\n                _loop_2(i);\r\n            }\r\n            return promise;\r\n        })\r\n            .then(function () {\r\n            _this.flushInProgress = false;\r\n            var queuedEvents = _this.eventQueue.slice();\r\n            _this.eventQueue = [];\r\n            return _this.emit(queuedEvents);\r\n        }));\r\n    };\r\n    return Pipeline;\r\n}());\r\nexport { Pipeline };\r\n","references":["C:/Users/bryce/Google Drive/Development/serilogger/src/logEvent.ts"],"dts":{"name":"C:/Users/bryce/Google Drive/Development/serilogger/pipeline.d.ts","writeByteOrderMark":false,"text":"import { LogEvent } from \"./logEvent\";\r\nexport interface PipelineStage {\r\n    emit(events: LogEvent[]): LogEvent[];\r\n    flush(): Promise<any>;\r\n}\r\nexport declare class Pipeline {\r\n    private stages;\r\n    private eventQueue;\r\n    private flushInProgress;\r\n    private flushPromise;\r\n    constructor();\r\n    /**\r\n     * Adds a stage to the end of the pipeline.\r\n     * @param {PipelineStage} stage The pipeline stage to add.\r\n     */\r\n    addStage(stage: PipelineStage): void;\r\n    /**\r\n     * Emits events through the pipeline. If a flush is currently in progress, the events will be queued and will been\r\n     * sent through the pipeline once the flush is complete.\r\n     * @param {LogEvent[]} events The events to emit.\r\n     */\r\n    emit(events: LogEvent[]): Promise<any>;\r\n    /**\r\n     * Flushes events through the pipeline.\r\n     * @returns A {Promise<any>} that resolves when all events have been flushed and the pipeline can accept new events.\r\n     */\r\n    flush(): Promise<any>;\r\n}\r\n"}}
