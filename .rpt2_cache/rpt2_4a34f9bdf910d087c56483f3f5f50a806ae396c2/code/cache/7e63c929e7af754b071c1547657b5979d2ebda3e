{"code":"import * as tslib_1 from \"tslib\";\r\nimport { LogEventLevel, isEnabled } from './logEvent';\r\nimport { FilterStage } from './filterStage';\r\n/**\r\n * Allows dynamic control of the logging level.\r\n */\r\nvar DynamicLevelSwitch = /** @class */ (function () {\r\n    function DynamicLevelSwitch() {\r\n        this.minLevel = null;\r\n        /**\r\n         * Gets or sets a delegate that can be called when the pipeline needs to be flushed.\r\n         * This should generally not be modified, as it will be provided by the pipeline stage.\r\n         */\r\n        this.flushDelegate = function () { return Promise.resolve(); };\r\n    }\r\n    DynamicLevelSwitch.prototype.fatal = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.flushDelegate()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.minLevel = LogEventLevel.fatal];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DynamicLevelSwitch.prototype.error = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.flushDelegate()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.minLevel = LogEventLevel.error];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DynamicLevelSwitch.prototype.warning = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.flushDelegate()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.minLevel = LogEventLevel.warning];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DynamicLevelSwitch.prototype.information = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.flushDelegate()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.minLevel = LogEventLevel.information];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DynamicLevelSwitch.prototype.debug = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.flushDelegate()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.minLevel = LogEventLevel.debug];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DynamicLevelSwitch.prototype.verbose = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.flushDelegate()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.minLevel = LogEventLevel.verbose];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DynamicLevelSwitch.prototype.off = function () {\r\n        return tslib_1.__awaiter(this, void 0, void 0, function () {\r\n            return tslib_1.__generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.flushDelegate()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this.minLevel = LogEventLevel.off];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    DynamicLevelSwitch.prototype.isEnabled = function (level) {\r\n        return this.minLevel === null || isEnabled(this.minLevel, level);\r\n    };\r\n    return DynamicLevelSwitch;\r\n}());\r\nexport { DynamicLevelSwitch };\r\nvar DynamicLevelSwitchStage = /** @class */ (function (_super) {\r\n    tslib_1.__extends(DynamicLevelSwitchStage, _super);\r\n    function DynamicLevelSwitchStage(dynamicLevelSwitch) {\r\n        var _this = _super.call(this, function (e) { return dynamicLevelSwitch.isEnabled(e.level); }) || this;\r\n        _this.dynamicLevelSwitch = dynamicLevelSwitch;\r\n        return _this;\r\n    }\r\n    /**\r\n     * Sets a delegate that can be called when the pipeline needs to be flushed.\r\n     */\r\n    DynamicLevelSwitchStage.prototype.setFlushDelegate = function (flushDelegate) {\r\n        this.dynamicLevelSwitch.flushDelegate = flushDelegate;\r\n    };\r\n    return DynamicLevelSwitchStage;\r\n}(FilterStage));\r\nexport { DynamicLevelSwitchStage };\r\n","references":["C:/Users/bryce/Google Drive/Development/serilogger/src/logEvent.ts","C:/Users/bryce/Google Drive/Development/serilogger/src/filterStage.ts"],"dts":{"name":"C:/Users/bryce/Google Drive/Development/serilogger/dynamicLevelSwitch.d.ts","writeByteOrderMark":false,"text":"import { LogEventLevel, LogEventLevelSwitch } from './logEvent';\r\nimport { FilterStage } from './filterStage';\r\n/**\r\n * Allows dynamic control of the logging level.\r\n */\r\nexport declare class DynamicLevelSwitch implements LogEventLevelSwitch<Promise<any>> {\r\n    private minLevel;\r\n    /**\r\n     * Gets or sets a delegate that can be called when the pipeline needs to be flushed.\r\n     * This should generally not be modified, as it will be provided by the pipeline stage.\r\n     */\r\n    flushDelegate: () => Promise<any>;\r\n    fatal(): Promise<LogEventLevel>;\r\n    error(): Promise<LogEventLevel>;\r\n    warning(): Promise<LogEventLevel>;\r\n    information(): Promise<LogEventLevel>;\r\n    debug(): Promise<LogEventLevel>;\r\n    verbose(): Promise<LogEventLevel>;\r\n    off(): Promise<LogEventLevel>;\r\n    isEnabled(level: LogEventLevel): boolean;\r\n}\r\nexport declare class DynamicLevelSwitchStage extends FilterStage {\r\n    private dynamicLevelSwitch;\r\n    /**\r\n     * Sets a delegate that can be called when the pipeline needs to be flushed.\r\n     */\r\n    setFlushDelegate(flushDelegate: () => Promise<any>): void;\r\n    constructor(dynamicLevelSwitch: DynamicLevelSwitch);\r\n}\r\n"}}
