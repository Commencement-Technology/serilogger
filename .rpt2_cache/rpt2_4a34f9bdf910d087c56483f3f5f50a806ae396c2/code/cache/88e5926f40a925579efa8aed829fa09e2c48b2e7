{"code":"import * as tslib_1 from \"tslib\";\r\nimport { MessageTemplate } from \"./messageTemplate\";\r\nexport var defaultBatchedSinkOptions = {\r\n    maxSize: 100,\r\n    period: 5,\r\n    durableStore: undefined\r\n};\r\nvar BatchedSink = /** @class */ (function () {\r\n    function BatchedSink(innerSink, options) {\r\n        this.durableStorageKey = \"serilogger-batched-sink-durable-cache\";\r\n        this.batchKey = '';\r\n        this.innerSink = innerSink || undefined;\r\n        this.options = tslib_1.__assign({}, defaultBatchedSinkOptions, (options || {}));\r\n        this.batchedEvents = [];\r\n        this.cycleBatch();\r\n        if (this.options.durableStore) {\r\n            var initialBatch = [];\r\n            for (var key in this.options.durableStore) {\r\n                if (key.indexOf(this.durableStorageKey) === 0) {\r\n                    var storedEvents = JSON.parse(this.options.durableStore.getItem(key)).map(function (e) {\r\n                        e.messageTemplate = new MessageTemplate(e.messageTemplate.raw);\r\n                        return e;\r\n                    });\r\n                    initialBatch = initialBatch.concat(storedEvents);\r\n                    this.options.durableStore.removeItem(key);\r\n                }\r\n            }\r\n            this.emit(initialBatch);\r\n        }\r\n    }\r\n    BatchedSink.prototype.emit = function (events) {\r\n        var _a, _b, _c;\r\n        if (this.batchedEvents.length + events.length <= this.options.maxSize) {\r\n            (_a = this.batchedEvents).push.apply(_a, events);\r\n            this.storeEvents();\r\n        }\r\n        else {\r\n            var cursor = this.options.maxSize - this.batchedEvents.length < 0\r\n                ? 0\r\n                : this.options.maxSize - this.batchedEvents.length;\r\n            (_b = this.batchedEvents).push.apply(_b, events.slice(0, cursor));\r\n            this.storeEvents();\r\n            while (cursor < events.length) {\r\n                this.cycleBatch();\r\n                (_c = this.batchedEvents).push.apply(_c, events.slice(cursor, (cursor = cursor + this.options.maxSize)));\r\n                this.storeEvents();\r\n            }\r\n        }\r\n        return events;\r\n    };\r\n    BatchedSink.prototype.flush = function () {\r\n        this.cycleBatch();\r\n        var corePromise = this.flushCore();\r\n        return corePromise instanceof Promise ? corePromise : Promise.resolve();\r\n    };\r\n    BatchedSink.prototype.emitCore = function (events) {\r\n        return this.innerSink ? this.innerSink.emit(events) : null;\r\n    };\r\n    BatchedSink.prototype.flushCore = function () {\r\n        return this.innerSink ? this.innerSink.flush() : Promise.resolve();\r\n    };\r\n    BatchedSink.prototype.cycleBatch = function () {\r\n        var _this = this;\r\n        if (this.batchTimeout)\r\n            clearTimeout(this.batchTimeout);\r\n        if (this.batchedEvents.length) {\r\n            var processEvents_1 = this.batchedEvents.slice(0);\r\n            this.batchedEvents.length = 0;\r\n            var emitPromise = this.emitCore(processEvents_1);\r\n            (emitPromise instanceof Promise ? emitPromise : Promise.resolve())\r\n                .then(function () {\r\n                if (_this.options.durableStore) {\r\n                    var previousBatchKey = _this.batchKey;\r\n                    return _this.options.durableStore.removeItem(previousBatchKey);\r\n                }\r\n            })\r\n                .catch(function () {\r\n                var _a;\r\n                (_a = _this.batchedEvents).unshift.apply(_a, processEvents_1);\r\n            });\r\n        }\r\n        this.batchKey = this.durableStorageKey + \"-\" + new Date().getTime();\r\n        if (!isNaN(this.options.period) && this.options.period > 0) {\r\n            this.batchTimeout = setTimeout(function () { return _this.cycleBatch(); }, this.options.period * 1000);\r\n        }\r\n    };\r\n    BatchedSink.prototype.storeEvents = function () {\r\n        if (this.options.durableStore) {\r\n            this.options.durableStore.setItem(this.batchKey, JSON.stringify(this.batchedEvents));\r\n        }\r\n    };\r\n    return BatchedSink;\r\n}());\r\nexport { BatchedSink };\r\n","references":["C:/Users/bryce/Google Drive/Development/serilogger/src/logEvent.ts","C:/Users/bryce/Google Drive/Development/serilogger/src/sink.ts","C:/Users/bryce/Google Drive/Development/serilogger/src/messageTemplate.ts"],"dts":{"name":"C:/Users/bryce/Google Drive/Development/serilogger/batchedSink.d.ts","writeByteOrderMark":false,"text":"import { LogEvent } from \"./logEvent\";\r\nimport { Sink } from \"./sink\";\r\nexport interface BatchedSinkOptions {\r\n    /**\r\n     * Maximum number of events to be sent in a single batch.\r\n     */\r\n    maxSize?: number;\r\n    /**\r\n     * Number of seconds to wait between checking for batches.\r\n     */\r\n    period?: number;\r\n    /**\r\n     * {Storage} instance to be used for durable storage of log events.\r\n     */\r\n    durableStore?: Storage;\r\n}\r\nexport declare const defaultBatchedSinkOptions: BatchedSinkOptions;\r\nexport declare class BatchedSink implements Sink {\r\n    protected durableStorageKey: string;\r\n    protected options: BatchedSinkOptions;\r\n    protected innerSink?: Sink;\r\n    protected batchedEvents: LogEvent[];\r\n    private batchTimeout;\r\n    private batchKey;\r\n    constructor(innerSink?: Sink, options?: BatchedSinkOptions);\r\n    emit(events: LogEvent[]): LogEvent[];\r\n    flush(): Promise<any>;\r\n    protected emitCore(events: LogEvent[]): any;\r\n    protected flushCore(): Promise<any>;\r\n    protected cycleBatch(): void;\r\n    private storeEvents;\r\n}\r\n"}}
